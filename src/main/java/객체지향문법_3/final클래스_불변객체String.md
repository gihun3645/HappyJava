## final 클래스, 불변객체 String

### 부모가 될 수 없는 클래스

- 상속을 금지시키려면 클래스를 정의할 때 final 키워드를 사용한다.
- public final class 클래스명  { ….. }

### String 클래스는 왜 final 일까?

없어서 chatGPT에 물어봄

Java에서 String 클래스는 **`final`** 클래스입니다. 이는 String 클래스가 불변(immutable) 클래스이기 때문입니다.

불변 클래스란, 객체의 내부 상태가 객체 생성 후에 변경될 수 없는 클래스를 말합니다. 예를 들어, String 객체를 생성하면 그 내용을 변경할 수 없습니다. 만약 변경하고 싶다면, 새로운 String 객체를 생성해야 합니다.

이와 같은 불변성은 String 객체가 안정적이고 예측 가능하며, 멀티스레드 환경에서 안전하게 사용될 수 있게 합니다. 또한, JVM은 String 객체를 효율적으로 관리할 수 있도록 최적화할 수 있습니다.

따라서, String 클래스를 **`final`**로 만들어서 상속이 불가능하게 함으로써, 불변성을 보장하고 안정적인 클래스로 만들어진 것입니다.

### String과 비슷하지만 내부가 변하는 StringBuffer 클래스

없어서 chatGPT에 물어봄

Java에서 **`StringBuffer`** 클래스는 문자열을 동적으로 관리할 수 있는 가변(mutable) 클래스입니다. 즉, **`String`** 클래스와 달리, **`StringBuffer`** 객체를 생성한 후, 객체 내의 문자열을 추가, 삭제, 수정할 수 있습니다.

**`StringBuffer`** 클래스는 문자열을 처리할 때, 내부적으로 버퍼(buffer)를 사용합니다. 버퍼란, 일시적으로 데이터를 저장하는 임시 공간을 말합니다. **`StringBuffer`** 클래스는 이 버퍼를 이용해서 문자열을 관리합니다.

**`StringBuffer`** 클래스는 **`String`** 클래스와 유사한 메서드를 제공합니다. 예를 들어, **`append()`**, **`insert()`**, **`delete()`**, **`replace()`** 등의 메서드를 사용하여 문자열을 추가, 삽입, 삭제, 수정할 수 있습니다.

**`StringBuffer`** 클래스는 멀티스레드 환경에서 동기화된(synchronized) 메서드를 제공합니다. 이는 **`StringBuffer`** 객체가 여러 스레드에서 동시에 접근되는 경우, 데이터 무결성을 보장하기 위해 사용됩니다.

하지만, **`StringBuffer`** 클래스는 동기화된 메서드를 사용하므로, 단일 스레드 환경에서는 **`StringBuilder`** 클래스를 사용하는 것이 더 효율적입니다. **`StringBuilder`** 클래스는 **`StringBuffer`** 클래스와 동일한 기능을 제공하지만, 동기화된 메서드를 제공하지 않습니다. 따라서, 단일 스레드 환경에서는 **`StringBuilder`** 클래스를 사용하는 것이 더 빠릅니다.